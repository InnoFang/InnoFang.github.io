<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Go语言学习笔记"><meta name="keywords" content="Go"><meta name="author" content="Inno Fang"><meta name="copyright" content="Inno Fang"><title>Go语言学习笔记 | Inno' Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Inno' Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">变量定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">内建变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.</span> <span class="toc-text">常量的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">定义枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.</span> <span class="toc-text">条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">5.1.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">5.2.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for"><span class="toc-number">6.1.</span> <span class="toc-text">for</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text">多个返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">7.3.</span> <span class="toc-text">可变参数列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">9.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">10.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.</span> <span class="toc-text">切片的创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.</span> <span class="toc-text">切片的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">切片的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">10.2.2.</span> <span class="toc-text">切片元素的删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">11.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text">结构的创建和简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">为结构定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">12.3.</span> <span class="toc-text">封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.</span> <span class="toc-text">扩充类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">14.1.</span> <span class="toc-text">接口的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.2.</span> <span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.3.</span> <span class="toc-text">使用接口实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F"><span class="toc-number">14.4.</span> <span class="toc-text">查看接口变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Type-Switch"><span class="toc-number">14.4.1.</span> <span class="toc-text">Type Switch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Type-Assertion"><span class="toc-number">14.4.2.</span> <span class="toc-text">Type Assertion</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">14.5.</span> <span class="toc-text">接口的组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer-%E8%B0%83%E7%94%A8"><span class="toc-number">15.</span> <span class="toc-text">defer 调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#panic"><span class="toc-number">16.1.</span> <span class="toc-text">panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recover"><span class="toc-number">16.2.</span> <span class="toc-text">recover</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">17.</span> <span class="toc-text">表格驱动测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-number">17.1.</span> <span class="toc-text">代码覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">17.2.</span> <span class="toc-text">性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">17.3.</span> <span class="toc-text">性能调优</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Goroutine"><span class="toc-number">18.</span> <span class="toc-text">Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">18.1.</span> <span class="toc-text">goroutine 的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine-%E5%8F%AF%E8%83%BD%E7%9A%84%E5%88%87%E6%8D%A2%E7%82%B9"><span class="toc-number">18.2.</span> <span class="toc-text">goroutine 可能的切换点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">19.</span> <span class="toc-text">通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">19.1.</span> <span class="toc-text">通道的注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD-channel"><span class="toc-number">19.2.</span> <span class="toc-text">关闭 channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Select"><span class="toc-number">19.3.</span> <span class="toc-text">Select</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/15724026?s=400&amp;u=ee5d1bee0d44d91b01465f82910464fda54b91cc&amp;v=4"></div><div class="author-info__name text-center">Inno Fang</div><div class="author-info__description text-center">Programming is an art form</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/InnoFang">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">65</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">18</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链 / links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://wmpscc.github.io/">HeoLis</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://barackbao.com/">Brarack Bao</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://wanghao15536870732.github.io/">HyYyr Wang</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.ingernotes.cn/">Inger Chao</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.angus-liu.cn/">Angus Liu 's Blog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://ww1.sinaimg.cn/large/0067fiZ7ly1g1i90sinjvj30sg0fnjvv.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Inno' Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/gallery">Gallery</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Go语言学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Go/">Go</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Go 语言入门</p>
<span id="more"></span>

<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> <span class="comment">// 定义 int 变量 a</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">10</span> <span class="comment">// 定义 int 变量 b 并赋初值</span></span><br><span class="line"><span class="keyword">var</span> c, d <span class="keyword">int</span> <span class="comment">// 定义多个 int 变量</span></span><br><span class="line"><span class="keyword">var</span> e, f <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span> <span class="comment">// 定义多个 int 型变量</span></span><br><span class="line"><span class="keyword">var</span> g, h, i, j = <span class="number">5</span>, <span class="number">6</span>, <span class="literal">true</span>, <span class="string">&quot;def&quot;</span> <span class="comment">// 使用类型推导为多个变量进行赋值</span></span><br><span class="line">k, l, m := <span class="number">7</span>, <span class="number">8.1</span>, <span class="literal">false</span>, <span class="string">&quot;def&quot;</span> <span class="comment">// 更简短的定义与赋值语句，:= 只能第一次用，往后要用 =</span></span><br><span class="line">						      <span class="comment">// 并且只能在函数内部使用，函数外部无法使用 :=</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	aa = <span class="number">1</span></span><br><span class="line">	bb = <span class="number">2.2</span></span><br><span class="line">	cc = <span class="string">&quot;define&quot;</span></span><br><span class="line">	dd = <span class="literal">true</span></span><br><span class="line">) <span class="comment">// 集中定义多个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数外的变量使用范围是包内部，GO 无全局变量的说法</span></span><br></pre></td></tr></table></figure>

<p><strong>TIPS</strong> 运行 GO 的 main 函数，所在包的包名也要是 main</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">//</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h2><ul>
<li><code>bool</code> 布尔型</li>
<li><code>string</code> 字符串型</li>
<li><code>(u)int</code>, <code>(u)int8</code>, <code>(u)int16</code>, <code>(u)int32</code>, <code>(u)int64</code>, <code>(u)intptr</code> 数字表示int位数，不加就默认为当前计算机位数，<code>ptr</code> 表示指针，u表示无符号</li>
<li><code>byte</code> 字节型，8位1字节</li>
<li><code>rune</code> Go语言的字符型，32位4个字节</li>
<li><code>float32</code>, <code>float64</code> 浮点型，数字为位数</li>
<li><code>complex64</code>, <code>complex128</code>  复数类型，前者实部和虚部都是 <code>float32</code>，后者两个都是 <code>float64</code></li>
</ul>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>Go语言类型转换是<strong>强制</strong>的</p>
<h2 id="常量的定义"><a href="#常量的定义" class="headerlink" title="常量的定义"></a>常量的定义</h2><p>与变量的定义有很多相似的地方，不过要用 <code>const</code> 代替 <code>var</code></p>
<p>定义常量的时候可以指定类型，也可以不指定类型，若不指定类型，就是个位置类型的文本，在使用的时候会进行推断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">int</span></span><br><span class="line">c = <span class="keyword">int</span>(math.Sqrt(a * a + b * b)) </span><br><span class="line"><span class="comment">// math.Sqrt 只能传入浮点数，若 a，b 指定了 int 型则会报错，若不指定则会当成 float</span></span><br></pre></td></tr></table></figure>

<h3 id="定义枚举类型"><a href="#定义枚举类型" class="headerlink" title="定义枚举类型"></a>定义枚举类型</h3><p>Go 语言没有枚举值，只能用 <code>const</code> 来模拟</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Mon = <span class="literal">iota</span></span><br><span class="line">	Tue</span><br><span class="line">	Wed</span><br><span class="line">	Thr</span><br><span class="line">	Fri</span><br><span class="line">	Sat</span><br><span class="line">	Sun</span><br><span class="line">)</span><br><span class="line">fmt.Println(Mon, Tue, Wed, Thr, Fri, Sat, Sun) <span class="comment">// 0， 1， 2， 3， 4， 5， 6</span></span><br></pre></td></tr></table></figure>

<p><code>iota</code> 是一个预先定义的标识符，在 <code>const</code> 表达式中（通常在括号内），用来表示当前 <code>const</code> 规范的非类型整数顺序数，索引为 0</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename = <span class="string">&quot;in.txt&quot;</span></span><br><span class="line">contents, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的条件语句的特点</p>
<ol>
<li>if 条件里可以赋值，且赋值的变量作用域只在这个 if 语句里</li>
<li>条件语句部分不需要括号，并且可以用 <code>;</code> 来分隔多个条件</li>
</ol>
<p>上面的例子可以进一步修改为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, contents)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">switch</span> op &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;+&quot;</span>: result = a + b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;-&quot;</span>: result = a - b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;*&quot;</span>: result = a * b</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;/&quot;</span>: result = a / b</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;unsupported operator:&quot;</span> + op)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言中 switch 的特点：</p>
<ol>
<li>swtich 会自动 break，除非使用 <code>falllthrough</code></li>
<li>switch 后可以没有表示，在 case 中写表达式也可以</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>去其他语言的 for 循环的区别在于没有 <code>( )</code>，并且三个部分各自都可以省略</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言中没有 while，如果把 for 玄幻的初始化和递增条件省略，就类似于 while</p>
<p>如果把三个部分都省略，那么就相当于死循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>Go 的函数可以返回多个值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以给返回值命名，可以增强代码可读性，也可以为编辑器的补全提供帮助。</p>
<p>若指明了返回值名称，则可以对返回值进行直接赋值，最后只需要一个 return 即可(该用法仅用于非常简单的函数，否则影响可读性)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	q = a / b</span><br><span class="line">	r = a % b</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Calling %s with (%d, %d)\n&quot;</span>, </span><br><span class="line">               reflect.ValueOf(op).Pointer(runtime.FuncForPC(p).Name()), </span><br><span class="line">               a, b)</span><br><span class="line">	<span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply(<span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p>Go 语言没有<code>默认参数</code>、<code>函数重载</code>，但有<code>可变参数列表</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	s := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">		s += numbers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go 语言的指针不能进行运算，这也是他简单的地方<br>Go 语言只有值传递一种方式（与值传递对应的是类似与 C++ 的引用传递，这个才 Go 中是没有的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func swap(a, b *int) &#123;</span><br><span class="line">	*a , *b = *b, *a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span> 			<span class="comment">// 定义长度为 5 的整型数组，默认值都为 0</span></span><br><span class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;		<span class="comment">// 定义并初始化长度为 3 的整型数组</span></span><br><span class="line">arr3 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// 不指定长度初始化一个整型数组</span></span><br><span class="line"><span class="keyword">var</span> grid [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>		   <span class="comment">// 定义 3 行 4 列的二维数组</span></span><br></pre></td></tr></table></figure>

<p>数组的遍历，可以使用 <code>range</code> 关键字，可以获得下标和值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只需要值不需要下标，则可以用 <code>__</code> 代替</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>若只要下标，则可以直接写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">range</span> arr &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Go 中的数组是值类型，也就是说数组传递给函数后，会拷贝数组内容，修改数组的值不会改变原数组的内容（大部分语言的数组都是引用传递，而 Go 则是值传递）。此外<code>[10]int</code> 和 <code>[20]int</code> 是不同类型，也就是说实参数组的长度要与形参数组的长度相一致，否则会报错。</p>
<p>要实现引用传递，则需要用到指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr[<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    foo(&amp;arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见使用数组还是相当麻烦的，所以在 Go 中使用的更多的是切片（Slice）</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">2</span>:<span class="number">6</span>])	<span class="comment">// [2 3 4 5]</span></span><br><span class="line">fmt.Println(arr[:<span class="number">6</span>])	<span class="comment">// [0 1 2 3 4 5]</span></span><br><span class="line">fmt.Println(arr[<span class="number">2</span>:])	<span class="comment">// [2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(arr[:])		<span class="comment">// [0 1 2 3 4 5 6 7]</span></span><br></pre></td></tr></table></figure>

<p>切片生成的是数组的一个视图，修改切片会改变原数组，在函数中传递数组时，若要方便修改原数组，可以使用切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123; ... &#125; <span class="comment">//  方括号内什么也没有就表示切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">    foo(arr[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<ol>
<li>slice 可以向后扩展，但是不能向前扩展</li>
<li>s[i] 不可以超越 len(s)，向后扩展不可以超越底层数组 caps(s)</li>
<li>向slice中添加元素，如果长度没超过 cap，则会覆盖原数组的内容，若超过cap，系统则会重新分配更大的底层数组</li>
<li>由于值传递，使用 append 有可能会修改 slice 的 len 或 cap ，因此必须接受 append 的返回值，即 <code>newSlc := append(slc, newValue)</code> </li>
</ol>
<h3 id="切片的创建方式"><a href="#切片的创建方式" class="headerlink" title="切片的创建方式"></a>切片的创建方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;		<span class="comment">// 定义并初始化切片，[]内什么都不加为切片，加...或数字为数组</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)		<span class="comment">// 创建长度为 16 的空切片</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">32</span>)	<span class="comment">// 创建长度为 16 ，底层数组长度为 32 的空切片</span></span><br></pre></td></tr></table></figure>

<h3 id="切片的操作"><a href="#切片的操作" class="headerlink" title="切片的操作"></a>切片的操作</h3><h4 id="切片的复制"><a href="#切片的复制" class="headerlink" title="切片的复制"></a>切片的复制</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(s1, s2) <span class="comment">// 把 s2 复制到 s1 上</span></span><br></pre></td></tr></table></figure>

<h4 id="切片元素的删除"><a href="#切片元素的删除" class="headerlink" title="切片元素的删除"></a>切片元素的删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">3</span>], [<span class="number">4</span>:]) <span class="comment">// 删除中间元素（第三个）</span></span><br><span class="line"></span><br><span class="line">front := s[<span class="number">0</span>]    		<span class="comment">// 取得头元素</span></span><br><span class="line">s = s[<span class="number">1</span>:]   	    	<span class="comment">// 删除头元素</span></span><br><span class="line"></span><br><span class="line">tail := s[<span class="built_in">len</span>(s) - <span class="number">1</span>]	<span class="comment">// 取得尾元素</span></span><br><span class="line">s = s[:<span class="built_in">len</span>(s)<span class="number">-1</span>]		<span class="comment">// 删除尾元素</span></span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>定义形式如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[K]V</span><br><span class="line"><span class="keyword">map</span>[K1]<span class="keyword">map</span>[K2]V	<span class="comment">// 复合map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Inno&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span> : <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gender&quot;</span> : <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[gender:male id:1234 name:Inno]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种定义 map 的方式</span></span><br><span class="line">m2 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) <span class="comment">// m2 == empty map</span></span><br><span class="line"><span class="keyword">var</span> m3 = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>   <span class="comment">// m3 == nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map 的遍历（不保证顺序）</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line">name := m[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">fmt.Println(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line"><span class="keyword">if</span> age, ok := m[<span class="string">&quot;age&quot;</span>]; ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;There is not a key called age!&quot;</span>)</span><br><span class="line">    <span class="comment">// 若元素不存在，获得的值也不是 nil 而是一个 zeroValue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 key</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;gender&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line"><span class="built_in">len</span>(m)</span><br></pre></td></tr></table></figure>

<ul>
<li>map 使用哈希表，必须可以比较相等</li>
<li>除了 slice、map、function 的内建类型都可以作为key</li>
<li>自建类型（Struct 类型）也可以作为 key，前提是没有 slice、map、function</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>Go 语言面向对象仅支持封装，不支持继承和多态；Go语言没有class，只有 struct</p>
<h3 id="结构的创建和简单使用"><a href="#结构的创建和简单使用" class="headerlink" title="结构的创建和简单使用"></a>结构的创建和简单使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> treeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value       <span class="keyword">int</span></span><br><span class="line">	left, right *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTreeNode</span><span class="params">(value <span class="keyword">int</span>)</span> *<span class="title">treeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;treeNode&#123;value: value&#125; <span class="comment">// 返回的是局部变量的地址！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> root treeNode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Go struct 有很多构造方法，所以可以不需要所谓的构造函数</span></span><br><span class="line"></span><br><span class="line">	root = treeNode&#123;value: <span class="number">3</span>&#125;</span><br><span class="line">	root.left = &amp;treeNode&#123;&#125;</span><br><span class="line">	root.right = &amp;treeNode&#123;<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">	root.right.left = <span class="built_in">new</span>(treeNode)</span><br><span class="line">	root.left.right = createTreeNode(<span class="number">2</span>) <span class="comment">// 使用工厂方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义在 Slice 中可以省略反复写 treeNode</span></span><br><span class="line">	nodes := []treeNode &#123;</span><br><span class="line">		&#123;value: <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;&#125;,</span><br><span class="line">		&#123;<span class="number">6</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(nodes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Q</strong> 在工厂方法中返回的局部变量的地址，该局部变量是创建在堆上还是在栈上？</p>
<p><strong>A</strong> 因为 Go 语言有垃圾回收机制，具体是在堆上还是在栈上，由编译器来决定。若是函数中的局部变量，那么建在栈上；若将局部变量的地址返回给外部调用，那么这个局部变量就会键在堆上，并参与垃圾回收，当不再使用时，就会被回收掉。所以退出函数后，局部变量就会被销毁，这是不一定的。</p>
<h3 id="为结构定义方法"><a href="#为结构定义方法" class="headerlink" title="为结构定义方法"></a>为结构定义方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(node.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(node treeNode)</code> 显示定义和命名方法接收者，随便叫什么都可以</li>
</ul>
<p>因为在Go语言中都是值传递，那么如果要在函数内修改值的话，值传递是无法生效的，因此可以使用指针作为方法接收者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    node.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有使用指针才可以改变结构内容</li>
<li><code>nil</code> 指针也可以调用方法</li>
</ul>
<p><strong>值接收者 VS 指针接收者</strong></p>
<ol>
<li>要改变内容时必须使用指针接收者</li>
<li>结构过大时也考虑使用指针接收者（因为值接收者是对值的拷贝，结果过大则消耗越大）</li>
<li>一致性：如果有指针接收者，最好都是指针接收者（一个建议，保持一致有利于阅读以及代码维护）</li>
<li>值接收者 是 Go 语言特有的</li>
<li>值/指针接收者均可接收值/指针</li>
</ol>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>名字一般使用CamelCase，首字母大写为 public，首字母小写为 private。</p>
<p>封装是对包而言的，每个目录可以有很多个包，但只能有一个main包，main 包包含可执行入口。</p>
<p>为结构定义的方法必须在同一个包内，但可以是不同文件。</p>
<h2 id="扩充类型"><a href="#扩充类型" class="headerlink" title="扩充类型"></a>扩充类型</h2><ol>
<li><p>使用别名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span> <span class="comment">//Queue 本质是一个int切片</span></span><br><span class="line"><span class="comment">// 扩展 []int，使其具有队列的功能</span></span><br><span class="line"><span class="comment">/* 入队 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;	<span class="comment">// 设计修改内容的要使用指针接收者</span></span><br><span class="line">    *q = <span class="built_in">append</span>(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 出队 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    head := (*q)[<span class="number">0</span>]</span><br><span class="line">    *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用组合</p>
</li>
</ol>
<p>利用组合为之前的 treeNode对象扩展一个遍历方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义新的结构体，使用组合的方式扩展类型</span></span><br><span class="line"><span class="keyword">type</span> myTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	node *treeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *myTreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> myNode == <span class="literal">nil</span> &amp;&amp; myNode.node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	left := myTreeNode&#123;myNode.node.left&#125;</span><br><span class="line">	right := myTreeNode&#123;myNode.node.right&#125;</span><br><span class="line"></span><br><span class="line">	left.postOrder()</span><br><span class="line">	right.postOrder()</span><br><span class="line">	myNode.node.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> root treeNode </span><br><span class="line">	<span class="comment">// 定义二叉树</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	myRoot := myTreeNode&#123;&amp;root&#125;</span><br><span class="line">	myRoot.postOrder() </span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p><em>使用者定义接口</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line">	Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r Retriever </span><br><span class="line">    <span class="comment">// 实现者待实现</span></span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>在接口所在目录下新建目录，创建新文件用来实现接口方法，当前目录结构为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LearnGo&gt;innofang.io&gt;innofang&gt;interfaces</span><br><span class="line">						    &gt;real</span><br><span class="line">						  	  |- main.go	// 接口实现所在位置</span><br><span class="line">						    |- main.go 		// 接口定义所在位置		</span><br></pre></td></tr></table></figure>

<p><em>只要实现了接口方法，就被认为实现了接口</em>，接口实现如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="built_in">real</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http/httputil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserAgent <span class="keyword">string</span></span><br><span class="line">	TimeOut time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要实现了接口方法，就被认为实现了接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	resp.Body.Close()	<span class="comment">// 使用完 response 需要关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用接口实现"><a href="#使用接口实现" class="headerlink" title="使用接口实现"></a>使用接口实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r Retriever</span><br><span class="line">	r = <span class="built_in">real</span>.Retriever&#123;&#125;	<span class="comment">// 使用接口 包名.结构体名</span></span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口里面有什么</strong></p>
<p>接口变量里面的内容有两种情况：</p>
<ol>
<li>实现者的类型和实现者的值</li>
<li>实现者的类型和实现者的指针，其中指针指向实现者</li>
</ol>
<p>具体是哪个，可以自由选择，因此在使用接口变量的时候，不要使用接口的地址，因为接口内部包含有指针</p>
<ul>
<li>接口变量自带指针</li>
<li>接口变量同样采用值传递，几乎不需要使用接口的指针</li>
<li>指针接收者实现只能以指针方式使用；值接收者都可</li>
</ul>
<p>若接口方法实现时使用了指针接收者，那么在定义该接口实习时，需要取接口地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 real 包下的 Get 方法实现，使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在定义该接口实现者时，就需要使用取地址符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> r Retriever</span><br><span class="line">	r = &amp;<span class="built_in">real</span>.Retriever&#123;&#125;</span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看接口变量"><a href="#查看接口变量" class="headerlink" title="查看接口变量"></a>查看接口变量</h3><p>再定义一个接口实现者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line">	Contents <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要实现了接口方法，就被认为实现了接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Contents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看接口变量有两种方式</p>
<h4 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := r.(<span class="keyword">type</span>) &#123; <span class="comment">// 获取类型</span></span><br><span class="line">	<span class="keyword">case</span> mock.Retriever:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Contents: &quot;</span>, v.Contents)</span><br><span class="line">	<span class="keyword">case</span> *<span class="built_in">real</span>.Retriever:</span><br><span class="line">		fmt.Println(<span class="string">&quot;UserAgent: &quot;</span>, v.UserAgent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Type-Assertion"><a href="#Type-Assertion" class="headerlink" title="Type Assertion"></a>Type Assertion</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">realRetriever := r.(*<span class="built_in">real</span>.Retriever) <span class="comment">// 通过</span></span><br><span class="line">fmt.Println(realRetriever.TimeOut)</span><br><span class="line"></span><br><span class="line"><span class="comment">//mockRetriever := r.(mock.Retriever)	// 错误，因为 r 在之前定义的是 real.Retriever</span></span><br><span class="line"><span class="comment">//fmt.Println(mockRetriever.Contents)   // 因此无法转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更优雅的转换方式</span></span><br><span class="line"><span class="keyword">if</span> mockRetriever, ok := r.(mock.Retriever); ok &#123;</span><br><span class="line">	fmt.Println(mockRetriever.Contents)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;not a mock&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表示任何类型</strong> ：<code>interface&#123;&#125;</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Quue []<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 该slice就可以接收任何类型的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *q = <span class="built_in">append</span>(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    head := (*q)[<span class="number">0</span>]</span><br><span class="line">    *q = (*q)][<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> head </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h3><p>假设有另一个结构体 Poster，现在要把含有 Get 方法的 Retriever 和含有 Post 方法的 Poster 进行组合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RetrieverPoster</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">    Retriever	<span class="comment">// 把结构体名包含进来就可以了</span></span><br><span class="line">    Poster</span><br><span class="line">    <span class="comment">// 也可以定义其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在对于实现者来说，他可以自己实现 Post 方法和 Get 方法了</p>
<p>使用者不管定义者如何定义，它只管实现它要的方法，不需要关心使用的是什么接口</p>
<p>只要是一个类型就可以实现接口，这也是 Go 语言灵活的地方</p>
<h2 id="defer-调用"><a href="#defer-调用" class="headerlink" title="defer 调用"></a>defer 调用</h2><p>何时使用 defer 调用 </p>
<ul>
<li>Open/Close</li>
<li>Lock/Unlock</li>
<li>PrintHeader/PrintFooter</li>
</ul>
<p>被 defer 修饰的语句会确保在函数结束时发生，无论这个程序是否被提前终止，如果有多个 defer 会有一个栈来存储语句，采用先进后出的顺序执行语句</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;abc.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line">    <span class="keyword">if</span> pathError, ok := err.(*os.PathError); !ok &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err) <span class="comment">// 如果是自定义 error 就会直接 panic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;%s, %s, %s\n&quot;</span>, pathError.Op, pathError.Path, pathError.Err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><ul>
<li>停止当前函数执行</li>
<li>一直向上返回，执行每一层的 defer</li>
<li>如果没有遇见 recover，程序退出</li>
</ul>
<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><ul>
<li>仅在 defer 调用中使用</li>
<li>获取 panic 的值</li>
<li>如果无法处理，可重新 0panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		r := <span class="built_in">recover</span>()</span><br><span class="line">		<span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">			<span class="comment">// 如果是 error， 则会进行处理</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;Error occured:&quot;</span>, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果不是 error，比如直接 `panic(123)` ，则不处理</span></span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprint(<span class="string">&quot;I don&#x27;t know what to do: %v&quot;</span>, r))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(errors.New(<span class="string">&quot;this is an error&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tryRecover()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表格驱动测试"><a href="#表格驱动测试" class="headerlink" title="表格驱动测试"></a>表格驱动测试</h2><ul>
<li>分离的测试数据和测试逻辑</li>
<li>明确的出错信息</li>
<li>可以部分失败</li>
<li>Go 语言的语法使得我们更易实践表格驱动测试</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        a, b, c  <span class="keyword">int32</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;math.MaxInt32, <span class="number">1</span>, math.MinInt32&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        <span class="keyword">if</span> actual := add(test.a, test.b); actual != test.c &#123;</span><br><span class="line">            <span class="comment">// 测试失败的说明</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><p>在测试文件所在目录下执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -coverprofile=c.out <span class="comment">// 运行测试代码</span></span><br><span class="line"><span class="keyword">go</span> tool cover -html=c.out	<span class="comment">// 展示覆盖率</span></span><br></pre></td></tr></table></figure>

<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Becnchmark</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    testCase := ...</span><br><span class="line">    ans := ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123; <span class="comment">// 具体运行多少遍不用管，b.N 由系统决定</span></span><br><span class="line">        actual := testedFunc(testCase)</span><br><span class="line">        <span class="keyword">if</span> actual != ans &#123;</span><br><span class="line">            b.Errorf(<span class="string">&quot;...&quot;</span>, ...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令行在测试文件所在目录下执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench .</span><br></pre></td></tr></table></figure>

<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>在测试文件所在目录下执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpuprofile cpu.out</span><br></pre></td></tr></table></figure>

<p>生成了二进制文件 <code>cpu.out</code>，接着使用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof cpu.out</span><br></pre></td></tr></table></figure>

<p>进入交互式命令行，可以使用 <code>help</code> 查看，最简单的方式是输入 <code>web</code> 查看二进制文件。内容上，看到的方框越大，说明耗时越久，优化方框大的部分可以使程序性能更有。</p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>协程</p>
<ul>
<li>轻量级“线程”</li>
<li>非抢占式多任务处理，由协程序主动交出控制权</li>
<li>编译器/解释器/虚拟机层面的多任务</li>
<li>多个协程可能在一个或多个线程上运行</li>
</ul>
<p>因为是非抢占式的 ，若不切换协程，则会一直执行一个协程（io操作会自动切换协程）。因此对于自定义协程，需要注意有没有手动交出控制权</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				a[i]++</span><br><span class="line">				runtime.Gosched() <span class="comment">// 手动交出控制权</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="goroutine-的定义"><a href="#goroutine-的定义" class="headerlink" title="goroutine 的定义"></a>goroutine 的定义</h3><ul>
<li>任何函数只需要加上 <code>go</code> 就能送给调度器运行</li>
<li>不需要在定义时区分是否是异步函数</li>
<li>调度器在合适的点进行切换 </li>
<li>调试时，在命令行使用 <code>-race</code> 来检测数据访问冲突  <code>go run -race goroutine.go</code></li>
</ul>
<h3 id="goroutine-可能的切换点"><a href="#goroutine-可能的切换点" class="headerlink" title="goroutine 可能的切换点"></a>goroutine 可能的切换点</h3><ul>
<li>I/O, select</li>
<li>channel</li>
<li>等待锁</li>
<li>函数调用（有时）</li>
<li>runtime.Gosched()</li>
</ul>
<p>只是参考，不能保证切换，不能保证在其他地方不切换</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>指的是 goroutine 之间的通道，可以让 goroutine 之间互相通信。每个通道都有与其相关的类型，即通道允许传输的数据类型。通道的零值为 nil，需要使用内置 make 方法来定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明通道</span></span><br><span class="line"><span class="keyword">var</span> 通道名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"><span class="comment">// 创建通道：如果通道为 nil（就是不存在），就需要创建通道</span></span><br><span class="line">通道名 = <span class="built_in">make</span>(<span class="keyword">chan</span> 数据类型)</span><br></pre></td></tr></table></figure>

<h3 id="通道的注意点"><a href="#通道的注意点" class="headerlink" title="通道的注意点"></a>通道的注意点</h3><p>Channel 通道在使用的时候，有以下几个注意点：</p>
<ol>
<li>用于 goroutine，传递消息</li>
<li>通道，每个都有相关联的数据类型，nil chan 是无法使用的</li>
<li>使用通道传递数据：&lt;-<ol>
<li>chan &lt;- data，发送数据到通道。向通道中写</li>
<li>data &lt;- chan，从通道中获取数据。从通道中读数据</li>
</ol>
</li>
<li>阻塞<ol>
<li>发送数据：chan &lt;- data，阻塞，直到另一条 goroutine 读取数据来接触阻塞</li>
<li>读取数据：data &lt;- chan，阻塞，知道另一条 goroutine 写入数据来接触阻塞</li>
</ol>
</li>
<li>Channel 是同步的，意味着同一时间只有一条 goroutine 来操作</li>
</ol>
<p><strong>注</strong> 通道是 goroutine 之间的连接，所以通道的发送和接收必须处在不同的 goroutine 中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data := &lt;- a <span class="comment">// 从通道 a 中读取数据</span></span><br><span class="line">a &lt;- data    <span class="comment">// 将数据写进通道 a 中</span></span><br></pre></td></tr></table></figure>

<p>定义方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var c chan int // c == nil</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n := &lt;- c</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line">time.Sleep(time.Millisecond)</span><br></pre></td></tr></table></figure>

<h3 id="关闭-channel"><a href="#关闭-channel" class="headerlink" title="关闭 channel"></a>关闭 channel</h3><p>channel 可以被发送方 close，但是 channel 即使被 close 了，也会接收数据，只不过收到的是 zeroValue</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 判断发送方是否关闭了 channel</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* // 方法一</span></span><br><span class="line"><span class="comment">		n, ok := &lt;-c </span></span><br><span class="line"><span class="comment">		if !ok &#123;  </span></span><br><span class="line"><span class="comment">			break</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		fmt.Printf(&quot;worker %d received %c\n&quot;, id, n)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="comment">// 方法二 利用 range (更好)</span></span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;worker %d received %c\n&quot;</span>, id, n)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送方发数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">go</span> worker(<span class="number">0</span>, c)</span><br><span class="line">	c &lt;- <span class="string">&#x27;a&#x27;</span></span><br><span class="line">	c &lt;- <span class="string">&#x27;b&#x27;</span></span><br><span class="line">	c &lt;- <span class="string">&#x27;c&#x27;</span></span><br><span class="line">	c &lt;- <span class="string">&#x27;d&#x27;</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>select 是 Go 中的一个控制结构，select 语句类似于 switch 语句，但是 select 会随机执行一个可执行的 case。如果没有 case 可运行，若设置了 default 则会执行 default，否则它将阻塞，直到有 case 可执行。语法结构上与 switch 语句很相似</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> communication clause:</span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">case</span> communication clause:</span><br><span class="line">    statement(s)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// optional</span></span><br><span class="line">    statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个 case 都必须是一个通信</li>
<li>所有 channel 表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果有多个 case 都可以运行，select 会随机公平地选出一个执行，其他不会执行</li>
<li>若此刻没有 case 语句可以执行时，若有default语句，则执行该语句；否则 select 将阻塞，知道有某个通信可以运行，Go 不会重新对 channel 或值进行求值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		ch1 &lt;- <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> num1 := &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Read from ch1:&quot;</span>, num1)</span><br><span class="line">	<span class="keyword">case</span> num2, ok := &lt;-ch2:</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Read from ch2:&quot;</span>, num2)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;ch2 has been closed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">		fmt.Println(<span class="string">&quot;After 3 seconds&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;default ...&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Inno Fang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://innofang.github.io/2020/02/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://innofang.github.io/2020/02/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/28/%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"><i class="fa fa-chevron-left">  </i><span>一个关于切片的小问题</span></a></div><div class="next-post pull-right"><a href="/2019/04/18/%E5%85%B3%E4%BA%8E%E8%8B%B1%E8%AF%91%E4%B8%AD%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%8A%80%E5%B7%A7/"><span>关于英译中的个人技巧</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://ww1.sinaimg.cn/large/0067fiZ7ly1g1i90sinjvj30sg0fnjvv.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2022 By Inno Fang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Programming is an art form.</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>